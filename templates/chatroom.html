<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Chat Room</title>
        <!-- import CSS -->
        <link href="chatroom.css" rel="stylesheet">
    </head>

    <body>
        <div>
            <h2>Hi, user</h2>

            <!-- message container -->
            <div id="messageShow">

            </div>

            <br>


            <!-- message input -->
            <textarea id="messageInput">

            </textarea>

            <br>

            <!-- send button-->
            <button id="messageSend">
                Send
            </button>

        </div>

        <!-- Script -->

        <!-- jQuery -->
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

        <!-- Script -->
        <script type="text/javascript">

            // chat room function
            function sendMessage() {

            }
            
            // Start 
            // User data structure
            class User{
                constructor(name){
                    this.name = name;
                    this.userID;
                    this.privateKey;
                    this.publicKey;
                    this.secret;
                    this.macKey = [];
                    this.encryptKey = [];
                    this.receiver = [];
                    //this.keyID = [];
                    this.salt = new Uint8Array(16);


                    // get back previous key from local storage
                   
                    const tempEncryptArray = localStorage.getItem('my_encryptKey');
                    // get encryptArray
                    if(tempEncryptArray == null){
                        //if no existing encryptKey array, create a new one
                        localStorage.setItem('my_encryptKey', JSON.stringify(this.encryptKey));
                    }
                    else{
                        const tempEncryptJson = JSON.parse(tempEncryptArray);
                        for(let i = 0; i < tempEncryptJson.length; i++){
                            encryptKey_import(this,tempEncryptJson[i]);
                        }
                        const tempEncryptArrayAfter = localStorage.getItem('my_encryptKey');

                    }

                    const tempMacArray = localStorage.getItem('my_macKey');
                    // get macArray
                    if(tempMacArray == null){
                        //if no existing macKey array, create a new one
                        localStorage.setItem('my_macKey', JSON.stringify(this.macKey));
                    }
                    else{
                        const tempMacJson = JSON.parse(tempMacArray);
                        for(let i = 0; i < tempMacJson.length; i++){
                            macKey_import(this,tempMacJson[i]);
                        }
                    }

                    
                    const tempSalt = localStorage.getItem('my_salt');
                    // gett salt
                    if(tempSalt == null){
                        //if no existing salt array, create a new one
                        localStorage.setItem('my_salt', JSON.stringify(this.salt));
                    }
                    else{
                        this.salt = new Uint8Array(JSON.parse(tempSalt));
                        
                    }
                        
                }

                updatePrivateKey(key){
                    this.privateKey = key;
                }

                updatePublicKey(key){
                    this.publicKey = key;
                }

                updateSecret(key){
                    this.secret = key;
                }

                updateMacKey(key){
                    this.macKey.push(key);
                }

                updateEncryptKey(key){
                    this.encryptKey.push(key);
                }

                updateSalt(){
                    let count = this.salt.length -1;
                    while ( count >= 0) {
                        if(this.salt[count]===255){
                            this.salt[count] = 0;
                            count--;
                        }
                        else{
                            this.salt[count]++;
                            break;
                        }
                        
                    }
                    localStorage.setItem('my_salt', JSON.stringify(Array.from(this.salt)));
                }

                updateIV(){

                }


            }

            // check Local storage have Private Key or not
            function checkKey(User){
                if(true){

                }
                // No, Local storage Key, generate a new Private Key
                else{
                generateNewKey();
                }
            }



            











            // key generation function
            function generateNewKey(){

            }

            // step1: generate pair of ECDH key pair--------------------------------------------------------------------
            // export ECDH Private Key
            async function ECDH_Private_Export(myPrivateKey,User){
                    const exportKey = await window.crypto.subtle.exportKey("jwk", myPrivateKey);
                    localStorage.setItem("my_ECDH_PrivateKey", JSON.stringify(exportKey));
                    //console.log("my_ECDH_PrivateKey export success:", localStorage.getItem("my_ECDH_PrivateKey"));
                    // use the imported one to ensure it is success
                    await ECDH_Private_import(User);
            }  

            // import ECDH Private Key
            async function ECDH_Private_import(User){
                    const jwk = JSON.parse(localStorage.getItem("my_ECDH_PrivateKey"));    
                    let importKey = await window.crypto.subtle.importKey(
                        "jwk", 
                        jwk, 
                        { name: "ECDH", namedCurve: "P-384", }, 
                        true, 
                        ["deriveKey"]
                    );
                    User.updatePrivateKey(await importKey);
            }   

            // export ECDH Public Key
            async function ECDH_Public_Export(myPublicKey,User){
                    const exportKey = await window.crypto.subtle.exportKey("jwk", myPublicKey);
                    localStorage.setItem("my_ECDH_PublicKey", JSON.stringify(exportKey));
                    //console.log("my_ECDH_PublicKey export success:", localStorage.getItem("my_ECDH_PublicKey"));
                    // use the imported one to ensure it is success
                    await ECDH_Public_import(User);
            }  

            // import ECDH Public Key
            async function ECDH_Public_import(User){
                    const jwk = JSON.parse(localStorage.getItem("my_ECDH_PublicKey"));    
                    let importKey = await window.crypto.subtle.importKey(
                        "jwk", 
                        jwk, 
                        { name: "ECDH", namedCurve: "P-384", }, 
                        true, 
                        [],
                    );
                    User.updatePublicKey(await importKey);
            }  

            async function generateECDH(User){

                let myECDHKeyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: "P-384",
                    },
                    true,
                    ["deriveKey"],

                )
                    console.log("Debug: ECDH key pair DONE", myECDHKeyPair) //Debug Msg: generate success

                    // seperate it to Private Key and Public Key
                    // Private key
                    let  myPrivateKey = myECDHKeyPair.privateKey;
                    await ECDH_Private_Export(myPrivateKey, User);
                    console.log("Debug: Your ECDH Private Key DONE", User.privateKey) //Debug Msg: generate success

                    // Public key
                    let  myPublicKey = myECDHKeyPair.publicKey;
                    await ECDH_Public_Export(myPublicKey, User);
                    console.log("Debug: Your ECDH Public Key DONE", User.publicKey) //Debug Msg: generate success
                
                
            }

            // step2: generate share secret--------------------------------------------------------------------

            //create a dummy friend Bob for debug-------------
            async function dummyBob(){
                let dummyKey =  await window.crypto.subtle.generateKey(
                {
                    name: "ECDH",
                    namedCurve: "P-384",
                },
                true,
                ["deriveKey"],
                )
                    console.log("Debug: Bob ECDH Privatte Key DONE", dummyKey.privateKey) //Debug Msg: generate success
                    console.log("Debug: Bob ECDH Public Key DONE", dummyKey.publicKey) //Debug Msg: generate success

                receiverJSON = {
                    key: dummyKey.publicKey,
                    name: "BOB"
                }

                return receiverJSON;
            
            }

            //derive share secret (you are user1)
            async function deriveSecret(User1, receiver){
                console.log("Debug: User1 ECDH Private Key", User1.privateKey); //Debug Msg: get private key success
                console.log("Debug: User2 ECDH Public Key", receiver.key); //Debug Msg: get public key success
                const mySecret = await window.crypto.subtle.deriveKey(
                    {
                        name: "ECDH",
                        public: receiver.key,
                    },
                    User1.privateKey,
                    {
                        name: "HKDF",
                        hash: "SHA-256",
                    },
                    false,
                    ["deriveKey"],
                )
                    User1.updateSecret(await mySecret);
                    console.log("Debug: Shared secret DONE", User1.secret) //Debug Msg: generate success

                    return mySecret;
                

                
            }

            // step3: generate encryption key by shared secret--------------------------------------------------------------------
            // export encryptKey to local storage
            async function encryptKey_export(encryptKey,User){
                const exportKey = await window.crypto.subtle.exportKey("jwk", encryptKey);
                let tempExportEncryptArray = localStorage.getItem('my_encryptKey');
                if(tempExportEncryptArray != null)tempExportEncryptArray = JSON.parse(tempExportEncryptArray);

                let arrayLength = User.encryptKey.length;
                let exportKeyMSG = {
                    keyID: arrayLength,
                    keyJWK: exportKey
                }
                
                tempExportEncryptArray.push(exportKeyMSG);
                localStorage.setItem("my_encryptKey", JSON.stringify(tempExportEncryptArray));

                await encryptKey_import(User,exportKeyMSG);
            }

            // import encryptKey from local storage
            async function encryptKey_import(User,exportKeyMSG){
                //const jwk = JSON.parse(localStorage.getItem("my_encryptKey"));    
                let tempEncryptArray = JSON.parse(localStorage.getItem("my_encryptKey"));
                let targetIndex = tempEncryptArray.findIndex(item => item.keyID === exportKeyMSG.keyID);
                let importKey = await window.crypto.subtle.importKey(
                    "jwk", 
                    tempEncryptArray[targetIndex].keyJWK, 
                    { name: "AES-GCM", length: 256 },
                    true, 
                    ["encrypt", "decrypt"],
                );
                User.updateEncryptKey(importKey);
                
            }

            // derive encryptKey
            async function deriveEcryptKey(User1){
                console.log("Debug: User secret Key", User1.secret); //Debug Msg: get secret success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success
                let infoString = User1.encryptKey.length;
                let encrpytKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "HKDF",
                        salt: User1.salt,
                        info: new Uint8Array(infoString),
                        hash: "SHA-256",
                    },
                    User1.secret,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"],
                )
                await encryptKey_export(encrpytKey, User1);
                User1.updateSalt();
                
                console.log("Debug: encryptKey DONE", User1.encryptKey[User1.encryptKey.length-1]) //Debug Msg: generate success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success

                return User1.encryptKey.length-1;
            }

            
            // step4: generate MAC key by encryptKey--------------------------------------------------------------------
            // export MAC to local storage
            async function macKey_export(macKey,User){
                const exportKey = await window.crypto.subtle.exportKey("jwk", macKey);
                let tempExportMacArray = localStorage.getItem('my_macKey');
                if(tempExportMacArray != null)tempExportMacArray = JSON.parse(tempExportMacArray);

                let arrayLength = User.macKey.length;
                let exportKeyMSG = {
                    keyID: arrayLength,
                    keyJWK: exportKey
                }
                
                tempExportMacArray.push(exportKeyMSG);
                localStorage.setItem("my_macKey", JSON.stringify(tempExportMacArray));

                await macKey_import(User,exportKeyMSG);
            }

            // import MAC from local storage
            async function macKey_import(User,exportKeyMSG){
                //const jwk = JSON.parse(localStorage.getItem("my_encryptKey"));    
                let tempMacArray = JSON.parse(localStorage.getItem("my_macKey"));
                let targetIndex = tempMacArray.findIndex(item => item.keyID === exportKeyMSG.keyID);
                let importKey = await window.crypto.subtle.importKey(
                    "jwk", 
                    tempMacArray[targetIndex].keyJWK, 
                    { name: "HMAC", hash: "SHA-256" },
                    true, 
                    ["sign", "verify"],
                );

                User.updateMacKey(importKey);
                
            }

            // derive MAC
            async function deriveMACKey(User1,secretKey){
                console.log("Debug: User Secret Key", secretKey); //Debug Msg: get secret success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success
                let infoString = User1.macKey.length;
                let macKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "HKDF",
                        salt: User1.salt,
                        info: new Uint8Array(infoString),
                        hash: "SHA-256",
                    },
                    secretKey,
                    { name: "HMAC", hash: "SHA-256" },
                    true,
                    ["sign", "verify"],
                )
                await macKey_export(macKey, User1);
                User1.updateSalt();
                
                console.log("Debug: MAC Key DONE", User1.macKey[User1.macKey.length-1]) //Debug Msg: generate success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success


            }

            //-------------------------------------

            // Encryption / Decryption function

            // encryption
            async function encryptMessage(msg, encryptKey){
                console.log("Debug: Start encrypt", msg); //Debug Msg: start encrpyt message
                console.log("Debug: Using encrypt key", encryptKey); //Debug Msg: start encrpyt message
                let encoder = new TextEncoder();
                let encodedMSG = encoder.encode(msg);

                const iv = await window.crypto.getRandomValues(new Uint8Array(12));
                let cipherText = await window.crypto.subtle.encrypt(
                { 
                    name: "AES-GCM", iv: iv },
                    encryptKey,
                    encodedMSG,
                );

                let cipherText_IV = {
                    cipherText:cipherText,
                    IV: iv
                }

                return cipherText_IV;
            }

            async function signMac(msg, macKey){
                console.log("Debug: Start MAC", msg); //Debug Msg: start HMAC message
                console.log("Debug: Using mac key", macKey); //Debug Msg: start encrpyt message
                let encoder = new TextEncoder();
                let encodedMSG = encoder.encode(msg);
                let sign = await window.crypto.subtle.sign(
                    {
                    name: "HMAC",
                    hash: { name: "SHA-256" },
                    }, 
                    macKey, 
                    encodedMSG
                );
                console.log("Debug: Signed", sign); //Debug Msg: get signed Message
                return sign;


            }

            async function encThenMac(User1,User2,msg){
                let cipherText_IV = await encryptMessage(msg,User1.encryptKey[0]);
                let macSignature = await signMac(cipherText_IV.cipherText,User1.macKey[0]);
                let signedMSG = {
                    cipherText: cipherText_IV.cipherText,
                    IV: cipherText_IV.IV,
                    signature: macSignature,
                }

                return signedMSG;

                
            }

            // decrpytion

            async function decrpytMessage(decryptKey, cipherText, IV){
                console.log("Debug: Start Decrypt", cipherText, "with IV ", IV); //Debug Msg: start HMAC message
                console.log("Debug: Using decrypt key", decryptKey); //Debug Msg: start encrpyt message

                let plaintext;

                try{
                    plaintext = await window.crypto.subtle.decrypt(
                        { 
                            name: "AES-GCM", iv: IV
                        }, 
                        decryptKey, 
                        cipherText
                    );


                }catch(error){
                    await console.error(error);
                }

                let decoder = new TextDecoder();
                plaintext = decoder.decode(plaintext);
                console.log("Debug: End decrypt", plaintext); //Debug Msg: get cipherText and IV
                return plaintext;
                

            }


            async function verifyMac(macKey, signature, cipherText){
                console.log("Debug: Start verify MAC", signature, "for ", cipherText); //Debug Msg: start HMAC message
                console.log("Debug: Using MAC key", macKey); //Debug Msg: start encrpyt message

                let verified = false;

                let encoder = new TextEncoder();
                let encodedMSG = encoder.encode(cipherText);


                try{
                    verified = await window.crypto.subtle.verify(
                        { 
                            name: "HMAC",
                            hash: { name: "SHA-256" }
                        }, 
                        macKey, 
                        signature,
                        encodedMSG
                    );

                    console.log("Debug: MAC Verify", verified); //Debug Msg: get cipherText and IV
                    return verified;
                

                }catch(error){
                    await console.error(error);
                }
                
            }


            async function verThenDec(User1, signedMSG){
                let plaintext = "decrypt failed";
                verifiedResult = await verifyMac(User1.macKey[0], signedMSG.signature, signedMSG.cipherText);
                if(verifiedResult == true){
                    plaintext = decrpytMessage(User1.encryptKey[0], signedMSG.cipherText, signedMSG.IV);
                }
                return plaintext
            }











            //--------------start-----------------------
            
            
            async function runProgram(){

                const Alice = new User("User");       

                await generateECDH(Alice);
                let receiver = await dummyBob("Bob");
                let secret = await deriveSecret(Alice,receiver);
                let indexMAC = await deriveEcryptKey(Alice);
                await deriveMACKey(Alice, secret);
                let test = await encThenMac(Alice,receiver,"Hi");
                await verThenDec(Alice, test);



            }

            document.addEventListener('DOMContentLoaded', runProgram);

//
//                       _oo0oo_
//                      o8888888o
//                      88" . "88
//                      (| -_- |)
//                      0\  =  /0
//                    ___/`---'\___
//                  .' \\|     |// '.
//                 / \\|||  :  |||// \
//                / _||||| -:- |||||- \
//               |   | \\\  -  /// |   |
//               | \_|  ''\---/''  |_/ |
//               \  .-\__  '-'  ___/-. /
//             ___'. .'  /--.--\  `. .'___
//          ."" '<  `.___\_<|>_/___.' >' "".
//         | | :  `- \`.;`\ _ /`;.`/ - ` : | |
//         \  \ `_.   \_ __\ /__ _/   .-` /  /
//     =====`-.____`.___ \_____/___.-`___.-'=====
//                       `=---='
//
//
//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//               佛祖保佑         永无BUG
//
//
//
        </script>
    </body>
</html>