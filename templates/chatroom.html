<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Chat Room</title>
        <!-- import Bootstrap CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
        <!-- import CSS -->
        <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    </head>

    <body>
        <div>
            <h2>Hi, user</h2>

            <!-- message container -->
            <div id="messageShow">

            </div>

            <br>


            <!-- message input -->
            <textarea id="messageInput">

            </textarea>

            <br>

            <!-- send button-->
            <button id="messageSend">
                Send
            </button>

            <!-- send button-->
            <button id="KeyExchange">
                Exchange
            </button>


            

        </div>

        <!-- user selection sidebar-->
        <div class="sidebar">
            <h5>Select a user to chat</h5>
            <ul id="userList"></ul>
        </div>

        <!-- Script -->
        <!-- Bootstrap -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

        <!-- jQuery -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

        <!-- Socket.io -->
        <!-- integrity - not tampered, crossorigin - CORS -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js" integrity="sha512-8BHxHDLsOHx+flIrQ0DrZcea7MkHqRU5GbTHmbdzMRnAaoCIkZ97PqZcXJkKZckMMhqfoeaJE+DNUVuyoQsO3Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

        <!-- Script -->
        <script type="text/javascript">
            

            


            
            // Start 
            // User data structure
            class User{
                constructor(name){
                    this.name = name;
                    this.userID;
                    this.privateKey;
                    this.publicKey;
                    this.secret;
                    this.macKey = [];
                    this.encryptKey = [];
                    this.receiver = [];
                    //this.keyID = [];
                    this.salt = new Uint8Array(16);


                    // get back previous key from local storage
                   
                    const tempEncryptArray = localStorage.getItem('my_encryptKey');
                    // get encryptArray
                    if(tempEncryptArray == null){
                        //if no existing encryptKey array, create a new one
                        localStorage.setItem('my_encryptKey', JSON.stringify(this.encryptKey));
                    }
                    else{
                        const tempEncryptJson = JSON.parse(tempEncryptArray);
                        for(let i = 0; i < tempEncryptJson.length; i++){
                            encryptKey_import(this,tempEncryptJson[i]);
                        }
                        const tempEncryptArrayAfter = localStorage.getItem('my_encryptKey');

                    }

                    const tempMacArray = localStorage.getItem('my_macKey');
                    // get macArray
                    if(tempMacArray == null){
                        //if no existing macKey array, create a new one
                        localStorage.setItem('my_macKey', JSON.stringify(this.macKey));
                    }
                    else{
                        const tempMacJson = JSON.parse(tempMacArray);
                        for(let i = 0; i < tempMacJson.length; i++){
                            macKey_import(this,tempMacJson[i]);
                        }
                    }

                    
                    const tempSalt = localStorage.getItem('my_salt');
                    // gett salt
                    if(tempSalt == null){
                        //if no existing salt array, create a new one
                        localStorage.setItem('my_salt', JSON.stringify(this.salt));
                    }
                    else{
                        this.salt = new Uint8Array(JSON.parse(tempSalt));
                        
                    }
                        
                }

                updatePrivateKey(key){
                    this.privateKey = key;
                }

                updatePublicKey(key){
                    this.publicKey = key;
                }

                updateSecret(key){
                    this.secret = key;
                }

                updateMacKey(key){
                    this.macKey.push(key);
                }

                updateEncryptKey(key){
                    this.encryptKey.push(key);
                }

                updateSalt(){
                    let count = this.salt.length -1;
                    while ( count >= 0) {
                        if(this.salt[count]===255){
                            this.salt[count] = 0;
                            count--;
                        }
                        else{
                            this.salt[count]++;
                            break;
                        }
                        
                    }
                    localStorage.setItem('my_salt', JSON.stringify(Array.from(this.salt)));
                }

                updateIV(){

                }


            }

            // check Local storage have Private Key or not
            function checkKey(User){
                if(true){

                }
                // No, Local storage Key, generate a new Private Key
                else{
                generateNewKey();
                }
            }



            











            // key generation function
            function generateNewKey(){

            }

            // step1: generate pair of ECDH key pair--------------------------------------------------------------------
            // export ECDH Private Key
            async function ECDH_Private_Export(myPrivateKey,User){
                    const exportKey = await window.crypto.subtle.exportKey("jwk", myPrivateKey);
                    localStorage.setItem("my_ECDH_PrivateKey", JSON.stringify(exportKey));
                    //console.log("my_ECDH_PrivateKey export success:", localStorage.getItem("my_ECDH_PrivateKey"));
                    // use the imported one to ensure it is success
                    await ECDH_Private_import(User);
            }  

            // import ECDH Private Key
            async function ECDH_Private_import(User){
                    const jwk = JSON.parse(localStorage.getItem("my_ECDH_PrivateKey"));    
                    let importKey = await window.crypto.subtle.importKey(
                        "jwk", 
                        jwk, 
                        { name: "ECDH", namedCurve: "P-384", }, 
                        true, 
                        ["deriveKey"]
                    );
                    User.updatePrivateKey(await importKey);
            }   

            // export ECDH Public Key
            async function ECDH_Public_Export(myPublicKey,User){
                    const exportKey = await window.crypto.subtle.exportKey("jwk", myPublicKey);
                    localStorage.setItem("my_ECDH_PublicKey", JSON.stringify(exportKey));
                    //console.log("my_ECDH_PublicKey export success:", localStorage.getItem("my_ECDH_PublicKey"));
                    // use the imported one to ensure it is success
                    await ECDH_Public_import(User);
            }  

            // import ECDH Public Key
            async function ECDH_Public_import(User){
                    const jwk = JSON.parse(localStorage.getItem("my_ECDH_PublicKey"));    
                    let importKey = await window.crypto.subtle.importKey(
                        "jwk", 
                        jwk, 
                        { name: "ECDH", namedCurve: "P-384", }, 
                        true, 
                        [],
                    );
                    User.updatePublicKey(await importKey);
            }  

            async function generateECDH(User){

                let myECDHKeyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: "P-384",
                    },
                    true,
                    ["deriveKey"],

                )
                    console.log("Debug: ECDH key pair DONE", myECDHKeyPair) //Debug Msg: generate success

                    // seperate it to Private Key and Public Key
                    // Private key
                    let  myPrivateKey = myECDHKeyPair.privateKey;
                    await ECDH_Private_Export(myPrivateKey, User);
                    console.log("Debug: Your ECDH Private Key DONE", User.privateKey) //Debug Msg: generate success

                    // Public key
                    let  myPublicKey = myECDHKeyPair.publicKey;
                    await ECDH_Public_Export(myPublicKey, User);
                    console.log("Debug: Your ECDH Public Key DONE", User.publicKey) //Debug Msg: generate success
                
                
            }

            // step2: generate share secret--------------------------------------------------------------------

            //create a dummy friend Bob for debug-------------
            async function dummyBob(){
                let dummyKey =  await window.crypto.subtle.generateKey(
                {
                    name: "ECDH",
                    namedCurve: "P-384",
                },
                true,
                ["deriveKey"],
                )
                    console.log("Debug: Bob ECDH Privatte Key DONE", dummyKey.privateKey) //Debug Msg: generate success
                    console.log("Debug: Bob ECDH Public Key DONE", dummyKey.publicKey) //Debug Msg: generate success

                receiverJSON = {
                    key: dummyKey.publicKey,
                    name: "BOB"
                }

                return receiverJSON;
            
            }

            //derive share secret (you are user1)
            async function deriveSecret(User1, receiverKey){ 
                console.log("Debug: User1 ECDH Private Key", User1.privateKey); //Debug Msg: get private key success
                console.log("Debug: User2 ECDH Public Key", receiverKey); //Debug Msg: get public key success
                const mySecret = await window.crypto.subtle.deriveKey(
                    {
                        name: "ECDH",
                        public: receiverKey,
                    },
                    User1.privateKey,
                    {
                        name: "HKDF",
                        hash: "SHA-256",
                    },
                    false,
                    ["deriveKey"],
                )
                    User1.updateSecret(await mySecret);
                    console.log("Debug: Shared secret DONE", User1.secret) //Debug Msg: generate success

                    return mySecret;
                

                
            }

            // step3: generate encryption key by shared secret--------------------------------------------------------------------
            // export encryptKey to local storage
            async function encryptKey_export(encryptKey,User){
                const exportKey = await window.crypto.subtle.exportKey("jwk", encryptKey);
                let tempExportEncryptArray = localStorage.getItem('my_encryptKey');
                if(tempExportEncryptArray != null)tempExportEncryptArray = JSON.parse(tempExportEncryptArray);

                let arrayLength = User.encryptKey.length;
                let exportKeyMSG = {
                    keyID: arrayLength,
                    keyJWK: exportKey
                }
                
                tempExportEncryptArray.push(exportKeyMSG);
                localStorage.setItem("my_encryptKey", JSON.stringify(tempExportEncryptArray));

                await encryptKey_import(User,exportKeyMSG);
            }

            // import encryptKey from local storage
            async function encryptKey_import(User,exportKeyMSG){
                //const jwk = JSON.parse(localStorage.getItem("my_encryptKey"));    
                let tempEncryptArray = JSON.parse(localStorage.getItem("my_encryptKey"));
                let targetIndex = tempEncryptArray.findIndex(item => item.keyID === exportKeyMSG.keyID);
                let importKey = await window.crypto.subtle.importKey(
                    "jwk", 
                    tempEncryptArray[targetIndex].keyJWK, 
                    { name: "AES-GCM", length: 256 },
                    true, 
                    ["encrypt", "decrypt"],
                );
                User.updateEncryptKey(importKey);
                
            }

            // derive encryptKey
            async function deriveEcryptKey(User1){
                console.log("Debug: User secret Key", User1.secret); //Debug Msg: get secret success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success
                let infoString = User1.encryptKey.length;
                let encrpytKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "HKDF",
                        salt: User1.salt,
                        info: new Uint8Array(infoString),
                        hash: "SHA-256",
                    },
                    User1.secret,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"],
                )
                await encryptKey_export(encrpytKey, User1);
                User1.updateSalt();
                
                console.log("Debug: encryptKey DONE", User1.encryptKey[User1.encryptKey.length-1]) //Debug Msg: generate success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success

                return User1.encryptKey.length-1;
            }

            
            // step4: generate MAC key by encryptKey--------------------------------------------------------------------
            // export MAC to local storage
            async function macKey_export(macKey,User){
                const exportKey = await window.crypto.subtle.exportKey("jwk", macKey);
                let tempExportMacArray = localStorage.getItem('my_macKey');
                if(tempExportMacArray != null)tempExportMacArray = JSON.parse(tempExportMacArray);

                let arrayLength = User.macKey.length;
                let exportKeyMSG = {
                    keyID: arrayLength,
                    keyJWK: exportKey
                }
                
                tempExportMacArray.push(exportKeyMSG);
                localStorage.setItem("my_macKey", JSON.stringify(tempExportMacArray));

                await macKey_import(User,exportKeyMSG);
            }

            // import MAC from local storage
            async function macKey_import(User,exportKeyMSG){
                //const jwk = JSON.parse(localStorage.getItem("my_encryptKey"));    
                let tempMacArray = JSON.parse(localStorage.getItem("my_macKey"));
                let targetIndex = tempMacArray.findIndex(item => item.keyID === exportKeyMSG.keyID);
                let importKey = await window.crypto.subtle.importKey(
                    "jwk", 
                    tempMacArray[targetIndex].keyJWK, 
                    { name: "HMAC", hash: "SHA-256" },
                    true, 
                    ["sign", "verify"],
                );

                User.updateMacKey(importKey);
                
            }

            // derive MAC
            async function deriveMACKey(User1,secretKey){
                console.log("Debug: User Secret Key", secretKey); //Debug Msg: get secret success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success
                let infoString = User1.macKey.length;
                let macKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "HKDF",
                        salt: User1.salt,
                        info: new Uint8Array(infoString),
                        hash: "SHA-256",
                    },
                    secretKey,
                    { name: "HMAC", hash: "SHA-256" },
                    true,
                    ["sign", "verify"],
                )
                await macKey_export(macKey, User1);
                User1.updateSalt();
                
                console.log("Debug: MAC Key DONE", User1.macKey[User1.macKey.length-1]) //Debug Msg: generate success
                console.log("Debug: User salt", User1.salt); //Debug Msg: get salt success


            }

            //-------------------------------------

            // Encryption / Decryption function

            // encryption
            async function encryptMessage(msg, encryptKey){
                console.log("Debug: Start encrypt", msg); //Debug Msg: start encrpyt message
                console.log("Debug: Using encrypt key", encryptKey); //Debug Msg: start encrpyt message
                let encoder = new TextEncoder();
                let encodedMSG = encoder.encode(msg);

                const iv = await window.crypto.getRandomValues(new Uint8Array(12));
                let cipherText = await window.crypto.subtle.encrypt(
                { 
                    name: "AES-GCM", iv: iv },
                    encryptKey,
                    encodedMSG,
                );

                let cipherText_IV = {
                    cipherText:cipherText,
                    IV: iv
                }

                return cipherText_IV;
            }

            async function signMac(msg, macKey){
                console.log("Debug: Start MAC", msg); //Debug Msg: start HMAC message
                console.log("Debug: Using mac key", macKey); //Debug Msg: start encrpyt message
                let encoder = new TextEncoder();
                let encodedMSG = encoder.encode(msg);
                let sign = await window.crypto.subtle.sign(
                    {
                    name: "HMAC",
                    hash: { name: "SHA-256" },
                    }, 
                    macKey, 
                    encodedMSG
                );
                console.log("Debug: Signed", await sign); //Debug Msg: get signed Message
                return sign;


            }

            async function encThenMac(User1,msg){
                let cipherText_IV = await encryptMessage(msg,User1.encryptKey[User1.encryptKey.length-1]);
                let macSignature = await signMac(cipherText_IV.cipherText,User1.macKey[User1.macKey.length-1]);
                let signedMSG = {
                    cipherText: cipherText_IV.cipherText,
                    IV: cipherText_IV.IV,
                    signature: macSignature,
                }

                return await signedMSG;

                
            }

            // decrpytion

            async function decrpytMessage(decryptKey, cipherText, IV){
                console.log("Debug: Start Decrypt", cipherText, "with IV ", IV); //Debug Msg: start HMAC message
                console.log("Debug: Using decrypt key", decryptKey); //Debug Msg: start encrpyt message

                let plaintext;

                try{
                    plaintext = await window.crypto.subtle.decrypt(
                        { 
                            name: "AES-GCM", iv: IV
                        }, 
                        decryptKey, 
                        cipherText
                    );


                }catch(error){
                    await console.error(error);
                }

                let decoder = new TextDecoder();
                plaintext = decoder.decode(plaintext);
                console.log("Debug: End decrypt", await plaintext); //Debug Msg: get cipherText and IV
                return plaintext;
                

            }


            async function verifyMac(macKey, signature, cipherText){
                console.log("Debug: Start verify MAC", signature, "for ", cipherText); //Debug Msg: start HMAC message
                console.log("Debug: Using MAC key", macKey); //Debug Msg: start encrpyt message

                let verified = false;

                let encoder = new TextEncoder();
                let encodedMSG = encoder.encode(cipherText);


                try{
                    verified = await window.crypto.subtle.verify(
                        { 
                            name: "HMAC",
                            hash: { name: "SHA-256" }
                        }, 
                        macKey, 
                        signature,
                        encodedMSG
                    );

                    console.log("Debug: MAC Verify", await verified); //Debug Msg: get cipherText and IV
                    return verified;
                

                }catch(error){
                    await console.error(error);
                }
                
            }


            async function verThenDec(User1, signedMSG){
                let plaintext = "decrypt failed";
                verifiedResult = await verifyMac(User1.macKey[User1.macKey.length-1], signedMSG.signature, signedMSG.cipherText);
                if(verifiedResult == true){
                    plaintext = await decrpytMessage(User1.encryptKey[User1.encryptKey.length-1], signedMSG.cipherText, signedMSG.IV);
                }
                return await plaintext
            }











            //--------------start-----------------------
            
            
            async function runProgram(){

                const Alice = new User("User");       

                await generateECDH(Alice);
                /*
                let receiverKey = await dummyBob("Bob");
                let secret = await deriveSecret(Alice,receiverKey.publicKey);
                let indexMAC = await deriveEcryptKey(Alice);
                await deriveMACKey(Alice, secret);
                let test = await encThenMac(Alice,"Hi");
                await verThenDec(Alice, test);
                */






            const client_id = '{{ client_id }}';
            const client_name = '{{ username }}';
            let receiver_id = -1;
            let receiver_name = '';
            let user_id_name = {};

            

            // chat room function
            var socket = io();
            // use below if ssl is enabled
            // const socket = io.connect('wss://' + document.domain + ':' + location.port);

            // generate user select list
            $(document).ready(function() {
                fetch('/users')
                .then(response => response.json())
                .then(data => {
                    console.log("Debug: Getting user list: ", data);
                    data.users.forEach(user => {
                        const user_id = user[0];
                        const username = user[1];
                        user_id_name[user_id] = username;
                        
                        console.log("Debug: Generating user list - User ID: ", user_id, " Username: ", username);
                        var listItem = $('<li>').text(username+' #'+user_id).attr({
                            'user_id': user_id,
                            'username': username                      
                        });
                        // select user
                        listItem.click(function() {
                            receiver_id = $(this).attr('user_id');
                            receiver_name = $(this).attr('username');
                            $('#userList li').removeClass('selected');
                            $(this).addClass('selected');
                            console.log("Debug: Selected user - User ID: ", receiver_id, " Username: ", receiver_name);
                            // erase previous messages
                            $('#messageShow').empty();
                            // load history messages                            
                            request_history_message();
                        });
                        $('#userList').append(listItem);
                    });
                })
            });

            // receive and load history messages
            socket.on('receive_history_message', function(messages) {
                console.log("Debug: Receiving history messages - Messages: ", messages);
                messages.forEach(message => {
                    console.log("Debug: Displaying history messages - Message: ", message.message_content, " Sender ID: ", message.sender_id, " Receiver ID: ", message.receiver_id);
                    displayMessage(message.message_content, message.sender_id, message.receiver_id);
                });
                console.log("Debug: All history messages have loaded");
            });


            // handshake
            socket.on('connect', function() {
                console.log("Debug: Connected to server, Client ID: ", client_id);
                socket.emit('handshake', client_id);
            });


            $('#KeyExchange').click( async function() {
                console.log("Debug:   Exchange Public Key: ", Alice.publicKey);
                const exportKey = await window.crypto.subtle.exportKey("jwk", Alice.publicKey);


                const data = {
                    sender_id: client_id,
                    receiver_id: receiver_id,
                    publicKey: JSON.stringify(exportKey)
                };
                socket.emit('send_public_key', data);
                console.log("Debug: Sending public key to server, Client ID: ", client_id, " Receiver ID: ", receiver_id, " Public Key: ", data.publicKey);
            });

            /*
            // send public key  
            socket.on('send_public_key', function(public_key) {
                
                const data = {
                    sender_id: client_id,
                    receiver_id: receiver_id,
                    public_key: public_key
                };
                socket.emit('public_key', client_id);
                console.log("Debug: Sending public key to server, Client ID: ", client_id, " Receiver ID: ", receiver_id, " Public Key: ", data.publicKey);
                
            });
*/

            //receive public key
            socket.on('receive_public_key', async function(data) {
                console.log("Debug: Receiving public key - Sender ID: ", data.sender_id, " Receiver ID: ", data.receiver_id, " Public Key: ", data.publicKey);
                const jwk = JSON.parse(data.publicKey);    
                    let importKey = await window.crypto.subtle.importKey(
                        "jwk", 
                        jwk, 
                        { name: "ECDH", namedCurve: "P-384", }, 
                        true, 
                        [],
                    );

                let secret = await deriveSecret(Alice, importKey);

                await deriveEcryptKey(Alice);
                await deriveMACKey(Alice, secret);
            });

            
            


            // send message
            $('#messageSend').click( async function() {
                const message = document.getElementById('messageInput').value;
                // not accept empty message, only whitespace
                if (message.trim() !== "" && receiver_id !== -1) {


                    const signedMSG = await encThenMac(Alice,message);
                    const data = {
                        sender_id: client_id,
                        receiver_id: receiver_id,
                        // encrypt message
                        message: message,
                        time: getCurrentTimestamp(),

                        //
                        cipherText: signedMSG.cipherText,
                        iv: signedMSG.IV,
                        signature: signedMSG.signature
    
                    };
                    // send to server
                    socket.emit('send_message', data);
                    console.log("Debug: Sending message - Sender ID: ", client_id, " Receiver ID: ", receiver_id, " Message: ", message, " cipherText: ", data.cipherText, " IV: ", data.iv,  " signature: ", data.signature);
                    displayMessage(message, client_id, receiver_id);
                    document.getElementById('messageInput').value = '';
                } else {
                    alert("Message cannot be empty!");
                }
            });
        
            // receive message
            socket.on('receive_message', async function(data) {
                // decrypt message
                console.log("Debug: Receiving message - Sender ID: ", data.sender_id, " Receiver ID: ", data.receiver_id, " Message: ", data.message, " cipherText: ", data.cipherText, " IV: ", data.iv, " signature: ", data.signature,);
                const message = data.message;
                const time = data.time;
                const sender_id = data.sender_id;
                const receiver_id = data.receiver_id;

                const signedMSG={
                    cipherText: data.cipherText,
                    IV: data.iv,
                    signature: data.signature
                }
                await verThenDec(Alice, signedMSG);
                displayMessage(message, sender_id, receiver_id);
            });

            // load history messages from server which include both sender and receiver
            function request_history_message() {
                // send request to server
                socket.emit('request_history_message', {sender_id: client_id, receiver_id: receiver_id});
            }

            

            // Function to get the current timestamp
            function getCurrentTimestamp() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0'); // (0-11)
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');

                return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            }
            
            


            

            // show history messages

            function displayMessage(message, sender_id, receiver_id){
                const messageShow = document.getElementById('messageShow');
                const messageElement = document.createElement('div');
                // decrypt message here
                messageElement.textContent = message;
                messageShow.appendChild(addStyleMessage(messageElement, sender_id, receiver_id));
                console.log("Debug: Displaying message - Sender ID: ", sender_id, " Receiver ID: ", receiver_id, " Message: ", message);
                messageElement.scrollTop = messageElement.scrollHeight;
                messageShow.scrollTop = messageShow.scrollHeight;
            }

            // add style to sent and received messages
            function addStyleMessage(messageElement, sender_id, receiver_id){
                // message sent from client
                if (sender_id == client_id){
                    messageElement.classList.add('sent_message');
                    console.log("Debug: Sent by Client - Client ID: ", sender_id);
                }
                // message received by client
                else if (receiver_id == client_id){
                    messageElement.classList.add('received_message');
                    console.log("Debug: Sent by Peer - Peer ID: ", receiver_id);
                }
                return messageElement;
            }


            }

            document.addEventListener('DOMContentLoaded', runProgram);

//
//                       _oo0oo_
//                      o8888888o
//                      88" . "88
//                      (| -_- |)
//                      0\  =  /0
//                    ___/`---'\___
//                  .' \\|     |// '.
//                 / \\|||  :  |||// \
//                / _||||| -:- |||||- \
//               |   | \\\  -  /// |   |
//               | \_|  ''\---/''  |_/ |
//               \  .-\__  '-'  ___/-. /
//             ___'. .'  /--.--\  `. .'___
//          ."" '<  `.___\_<|>_/___.' >' "".
//         | | :  `- \`.;`\ _ /`;.`/ - ` : | |
//         \  \ `_.   \_ __\ /__ _/   .-` /  /
//     =====`-.____`.___ \_____/___.-`___.-'=====
//                       `=---='
//
//
//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//               佛祖保佑         永无BUG
//
//
//
        </script>
    </body>
</html>